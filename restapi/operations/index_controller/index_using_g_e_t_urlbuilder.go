//// Code generated by go-swagger; DO NOT EDIT.
//
package index_controller
//
//// This file was generated by the swagger tool.
//// Editing this file might prove futile when you re-run the generate command
//
//import (
//	"errors"
//	"net/url"
//	golangswaggerpaths "path"
//)
//
//// IndexUsingGETURL generates an URL for the index using g e t operation
//type IndexUsingGETURL struct {
//	Claims     *object
//	Headers    *object
//	TokenValue *string
//
//	_basePath string
//	// avoid unkeyed usage
//	_ struct{}
//}
//
//// WithBasePath sets the base path for this url builder, only required when it's different from the
//// base path specified in the swagger spec.
//// When the value of the base path is an empty string
//func (o *IndexUsingGETURL) WithBasePath(bp string) *IndexUsingGETURL {
//	o.SetBasePath(bp)
//	return o
//}
//
//// SetBasePath sets the base path for this url builder, only required when it's different from the
//// base path specified in the swagger spec.
//// When the value of the base path is an empty string
//func (o *IndexUsingGETURL) SetBasePath(bp string) {
//	o._basePath = bp
//}
//
//// Build a url path and query string
//func (o *IndexUsingGETURL) Build() (*url.URL, error) {
//	var _result url.URL
//
//	var _path = "/jwt"
//
//	_basePath := o._basePath
//	if _basePath == "" {
//		_basePath = "/"
//	}
//	_result.Path = golangswaggerpaths.Join(_basePath, _path)
//
//	qs := make(url.Values)
//
//	var claimsQ string
//	if o.Claims != nil {
//		claimsQ = *o.Claims
//	}
//	if claimsQ != "" {
//		qs.Set("claims", claimsQ)
//	}
//
//	var headersQ string
//	if o.Headers != nil {
//		headersQ = *o.Headers
//	}
//	if headersQ != "" {
//		qs.Set("headers", headersQ)
//	}
//
//	var tokenValueQ string
//	if o.TokenValue != nil {
//		tokenValueQ = *o.TokenValue
//	}
//	if tokenValueQ != "" {
//		qs.Set("tokenValue", tokenValueQ)
//	}
//
//	_result.RawQuery = qs.Encode()
//
//	return &_result, nil
//}
//
//// Must is a helper function to panic when the url builder returns an error
//func (o *IndexUsingGETURL) Must(u *url.URL, err error) *url.URL {
//	if err != nil {
//		panic(err)
//	}
//	if u == nil {
//		panic("url can't be nil")
//	}
//	return u
//}
//
//// String returns the string representation of the path with query string
//func (o *IndexUsingGETURL) String() string {
//	return o.Must(o.Build()).String()
//}
//
//// BuildFull builds a full url with scheme, host, path and query string
//func (o *IndexUsingGETURL) BuildFull(scheme, host string) (*url.URL, error) {
//	if scheme == "" {
//		return nil, errors.New("scheme is required for a full url on IndexUsingGETURL")
//	}
//	if host == "" {
//		return nil, errors.New("host is required for a full url on IndexUsingGETURL")
//	}
//
//	base, err := o.Build()
//	if err != nil {
//		return nil, err
//	}
//
//	base.Scheme = scheme
//	base.Host = host
//	return base, nil
//}
//
//// StringFull returns the string representation of a complete url
//func (o *IndexUsingGETURL) StringFull(scheme, host string) string {
//	return o.Must(o.BuildFull(scheme, host)).String()
//}
