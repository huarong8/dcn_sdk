// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionModel TransactionModel
//
// swagger:model TransactionModel
type TransactionModel struct {

	// block hash
	// Required: true
	BlockHash *string `json:"blockHash"`

	// block number
	// Required: true
	BlockNumber *int64 `json:"blockNumber"`

	// cumulative gas used
	// Required: true
	CumulativeGasUsed *int64 `json:"cumulativeGasUsed"`

	// eth value
	// Required: true
	EthValue *float64 `json:"ethValue"`

	// from
	// Required: true
	From *string `json:"from"`

	// from links
	// Required: true
	FromLinks []*Link `json:"fromLinks"`

	// function meta
	FunctionMeta *FunctionMeta `json:"functionMeta,omitempty"`

	// gas
	// Required: true
	Gas *int64 `json:"gas"`

	// gas price
	// Required: true
	GasPrice *int64 `json:"gasPrice"`

	// gas used
	// Required: true
	GasUsed *int64 `json:"gasUsed"`

	// hash
	// Required: true
	Hash *string `json:"hash"`

	// input
	// Required: true
	Input *string `json:"input"`

	// is private
	// Required: true
	IsPrivate *bool `json:"isPrivate"`

	// logs
	// Required: true
	Logs []*Log `json:"logs"`

	// logs bloom
	// Required: true
	LogsBloom *string `json:"logsBloom"`

	// r
	// Required: true
	R *string `json:"r"`

	// s
	// Required: true
	S *string `json:"s"`

	// status
	Status string `json:"status,omitempty"`

	// timestamp i s o
	// Required: true
	TimestampISO *string `json:"timestampISO"`

	// to
	// Required: true
	To *string `json:"to"`

	// to links
	// Required: true
	ToLinks []*Link `json:"toLinks"`

	// transaction index
	// Required: true
	TransactionIndex *int64 `json:"transactionIndex"`

	// transaction type
	// Required: true
	// Enum: [Transfer ContractCreation ContractCall]
	TransactionType *string `json:"transactionType"`

	// v
	// Required: true
	V *int64 `json:"v"`

	// value
	// Required: true
	Value *int64 `json:"value"`

	// verified timestamp i s o
	// Required: true
	VerifiedTimestampISO *string `json:"verifiedTimestampISO"`
}

// Validate validates this transaction model
func (m *TransactionModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCumulativeGasUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEthValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFromLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFunctionMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGas(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGasPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGasUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInput(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsPrivate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLogsBloom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateR(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateS(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestampISO(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateV(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVerifiedTimestampISO(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionModel) validateBlockHash(formats strfmt.Registry) error {

	if err := validate.Required("blockHash", "body", m.BlockHash); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateBlockNumber(formats strfmt.Registry) error {

	if err := validate.Required("blockNumber", "body", m.BlockNumber); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateCumulativeGasUsed(formats strfmt.Registry) error {

	if err := validate.Required("cumulativeGasUsed", "body", m.CumulativeGasUsed); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateEthValue(formats strfmt.Registry) error {

	if err := validate.Required("ethValue", "body", m.EthValue); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateFrom(formats strfmt.Registry) error {

	if err := validate.Required("from", "body", m.From); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateFromLinks(formats strfmt.Registry) error {

	if err := validate.Required("fromLinks", "body", m.FromLinks); err != nil {
		return err
	}

	for i := 0; i < len(m.FromLinks); i++ {
		if swag.IsZero(m.FromLinks[i]) { // not required
			continue
		}

		if m.FromLinks[i] != nil {
			if err := m.FromLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateFunctionMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.FunctionMeta) { // not required
		return nil
	}

	if m.FunctionMeta != nil {
		if err := m.FunctionMeta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("functionMeta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("functionMeta")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionModel) validateGas(formats strfmt.Registry) error {

	if err := validate.Required("gas", "body", m.Gas); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateGasPrice(formats strfmt.Registry) error {

	if err := validate.Required("gasPrice", "body", m.GasPrice); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateGasUsed(formats strfmt.Registry) error {

	if err := validate.Required("gasUsed", "body", m.GasUsed); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateHash(formats strfmt.Registry) error {

	if err := validate.Required("hash", "body", m.Hash); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateInput(formats strfmt.Registry) error {

	if err := validate.Required("input", "body", m.Input); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateIsPrivate(formats strfmt.Registry) error {

	if err := validate.Required("isPrivate", "body", m.IsPrivate); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateLogs(formats strfmt.Registry) error {

	if err := validate.Required("logs", "body", m.Logs); err != nil {
		return err
	}

	for i := 0; i < len(m.Logs); i++ {
		if swag.IsZero(m.Logs[i]) { // not required
			continue
		}

		if m.Logs[i] != nil {
			if err := m.Logs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateLogsBloom(formats strfmt.Registry) error {

	if err := validate.Required("logsBloom", "body", m.LogsBloom); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateR(formats strfmt.Registry) error {

	if err := validate.Required("r", "body", m.R); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateS(formats strfmt.Registry) error {

	if err := validate.Required("s", "body", m.S); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateTimestampISO(formats strfmt.Registry) error {

	if err := validate.Required("timestampISO", "body", m.TimestampISO); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateTo(formats strfmt.Registry) error {

	if err := validate.Required("to", "body", m.To); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateToLinks(formats strfmt.Registry) error {

	if err := validate.Required("toLinks", "body", m.ToLinks); err != nil {
		return err
	}

	for i := 0; i < len(m.ToLinks); i++ {
		if swag.IsZero(m.ToLinks[i]) { // not required
			continue
		}

		if m.ToLinks[i] != nil {
			if err := m.ToLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("toLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("toLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) validateTransactionIndex(formats strfmt.Registry) error {

	if err := validate.Required("transactionIndex", "body", m.TransactionIndex); err != nil {
		return err
	}

	return nil
}

var transactionModelTypeTransactionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Transfer","ContractCreation","ContractCall"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionModelTypeTransactionTypePropEnum = append(transactionModelTypeTransactionTypePropEnum, v)
	}
}

const (

	// TransactionModelTransactionTypeTransfer captures enum value "Transfer"
	TransactionModelTransactionTypeTransfer string = "Transfer"

	// TransactionModelTransactionTypeContractCreation captures enum value "ContractCreation"
	TransactionModelTransactionTypeContractCreation string = "ContractCreation"

	// TransactionModelTransactionTypeContractCall captures enum value "ContractCall"
	TransactionModelTransactionTypeContractCall string = "ContractCall"
)

// prop value enum
func (m *TransactionModel) validateTransactionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionModelTypeTransactionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionModel) validateTransactionType(formats strfmt.Registry) error {

	if err := validate.Required("transactionType", "body", m.TransactionType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTransactionTypeEnum("transactionType", "body", *m.TransactionType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateV(formats strfmt.Registry) error {

	if err := validate.Required("v", "body", m.V); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	return nil
}

func (m *TransactionModel) validateVerifiedTimestampISO(formats strfmt.Registry) error {

	if err := validate.Required("verifiedTimestampISO", "body", m.VerifiedTimestampISO); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this transaction model based on the context it is used
func (m *TransactionModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFromLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFunctionMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateToLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionModel) contextValidateFromLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FromLinks); i++ {

		if m.FromLinks[i] != nil {
			if err := m.FromLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateFunctionMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.FunctionMeta != nil {
		if err := m.FunctionMeta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("functionMeta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("functionMeta")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionModel) contextValidateLogs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Logs); i++ {

		if m.Logs[i] != nil {
			if err := m.Logs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("logs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("logs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionModel) contextValidateToLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ToLinks); i++ {

		if m.ToLinks[i] != nil {
			if err := m.ToLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("toLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("toLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionModel) UnmarshalBinary(b []byte) error {
	var res TransactionModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
