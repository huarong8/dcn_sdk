// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TransactionRowModel TransactionRowModel
//
// swagger:model TransactionRowModel
type TransactionRowModel struct {

	// direction
	// Required: true
	// Enum: [In Out Self Unknown]
	Direction *string `json:"direction"`

	// eth value
	// Required: true
	EthValue *float64 `json:"ethValue"`

	// from
	// Required: true
	From *string `json:"from"`

	// from links
	// Required: true
	FromLinks []*Link `json:"fromLinks"`

	// function meta
	FunctionMeta *FunctionMeta `json:"functionMeta,omitempty"`

	// hash
	// Required: true
	Hash *string `json:"hash"`

	// is private
	// Required: true
	IsPrivate *bool `json:"isPrivate"`

	// timestamp i s o
	// Required: true
	TimestampISO *string `json:"timestampISO"`

	// to
	// Required: true
	To *string `json:"to"`

	// to links
	// Required: true
	ToLinks []*Link `json:"toLinks"`

	// transaction type
	// Required: true
	// Enum: [Transfer ContractCreation ContractCall]
	TransactionType *string `json:"transactionType"`

	// value
	// Required: true
	Value *int64 `json:"value"`
}

// Validate validates this transaction row model
func (m *TransactionRowModel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEthValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFromLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFunctionMeta(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsPrivate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestampISO(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var transactionRowModelTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["In","Out","Self","Unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionRowModelTypeDirectionPropEnum = append(transactionRowModelTypeDirectionPropEnum, v)
	}
}

const (

	// TransactionRowModelDirectionIn captures enum value "In"
	TransactionRowModelDirectionIn string = "In"

	// TransactionRowModelDirectionOut captures enum value "Out"
	TransactionRowModelDirectionOut string = "Out"

	// TransactionRowModelDirectionSelf captures enum value "Self"
	TransactionRowModelDirectionSelf string = "Self"

	// TransactionRowModelDirectionUnknown captures enum value "Unknown"
	TransactionRowModelDirectionUnknown string = "Unknown"
)

// prop value enum
func (m *TransactionRowModel) validateDirectionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionRowModelTypeDirectionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionRowModel) validateDirection(formats strfmt.Registry) error {

	if err := validate.Required("direction", "body", m.Direction); err != nil {
		return err
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", *m.Direction); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateEthValue(formats strfmt.Registry) error {

	if err := validate.Required("ethValue", "body", m.EthValue); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateFrom(formats strfmt.Registry) error {

	if err := validate.Required("from", "body", m.From); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateFromLinks(formats strfmt.Registry) error {

	if err := validate.Required("fromLinks", "body", m.FromLinks); err != nil {
		return err
	}

	for i := 0; i < len(m.FromLinks); i++ {
		if swag.IsZero(m.FromLinks[i]) { // not required
			continue
		}

		if m.FromLinks[i] != nil {
			if err := m.FromLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionRowModel) validateFunctionMeta(formats strfmt.Registry) error {
	if swag.IsZero(m.FunctionMeta) { // not required
		return nil
	}

	if m.FunctionMeta != nil {
		if err := m.FunctionMeta.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("functionMeta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("functionMeta")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionRowModel) validateHash(formats strfmt.Registry) error {

	if err := validate.Required("hash", "body", m.Hash); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateIsPrivate(formats strfmt.Registry) error {

	if err := validate.Required("isPrivate", "body", m.IsPrivate); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateTimestampISO(formats strfmt.Registry) error {

	if err := validate.Required("timestampISO", "body", m.TimestampISO); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateTo(formats strfmt.Registry) error {

	if err := validate.Required("to", "body", m.To); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateToLinks(formats strfmt.Registry) error {

	if err := validate.Required("toLinks", "body", m.ToLinks); err != nil {
		return err
	}

	for i := 0; i < len(m.ToLinks); i++ {
		if swag.IsZero(m.ToLinks[i]) { // not required
			continue
		}

		if m.ToLinks[i] != nil {
			if err := m.ToLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("toLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("toLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var transactionRowModelTypeTransactionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Transfer","ContractCreation","ContractCall"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		transactionRowModelTypeTransactionTypePropEnum = append(transactionRowModelTypeTransactionTypePropEnum, v)
	}
}

const (

	// TransactionRowModelTransactionTypeTransfer captures enum value "Transfer"
	TransactionRowModelTransactionTypeTransfer string = "Transfer"

	// TransactionRowModelTransactionTypeContractCreation captures enum value "ContractCreation"
	TransactionRowModelTransactionTypeContractCreation string = "ContractCreation"

	// TransactionRowModelTransactionTypeContractCall captures enum value "ContractCall"
	TransactionRowModelTransactionTypeContractCall string = "ContractCall"
)

// prop value enum
func (m *TransactionRowModel) validateTransactionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, transactionRowModelTypeTransactionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TransactionRowModel) validateTransactionType(formats strfmt.Registry) error {

	if err := validate.Required("transactionType", "body", m.TransactionType); err != nil {
		return err
	}

	// value enum
	if err := m.validateTransactionTypeEnum("transactionType", "body", *m.TransactionType); err != nil {
		return err
	}

	return nil
}

func (m *TransactionRowModel) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this transaction row model based on the context it is used
func (m *TransactionRowModel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFromLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFunctionMeta(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateToLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TransactionRowModel) contextValidateFromLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.FromLinks); i++ {

		if m.FromLinks[i] != nil {
			if err := m.FromLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("fromLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TransactionRowModel) contextValidateFunctionMeta(ctx context.Context, formats strfmt.Registry) error {

	if m.FunctionMeta != nil {
		if err := m.FunctionMeta.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("functionMeta")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("functionMeta")
			}
			return err
		}
	}

	return nil
}

func (m *TransactionRowModel) contextValidateToLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ToLinks); i++ {

		if m.ToLinks[i] != nil {
			if err := m.ToLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("toLinks" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("toLinks" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TransactionRowModel) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TransactionRowModel) UnmarshalBinary(b []byte) error {
	var res TransactionRowModel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
